import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import torch
import torch.nn as nn
import pefile
import os
import threading
from PIL import Image, ImageTk
import sys
import logging
import datetime

# Add this near the top of your file
logging.basicConfig(
    # filename=f'malware_detector_log_{datetime.datetime.now().strftime("%Y%m%d_%H%M%S")}.txt',
    # level=logging.INFO,
    # format='%(asctime)s - %(message)s'
)

# -----------------------------------------------------------------------------
# MalwareClassifier with dynamic input dimension
# -----------------------------------------------------------------------------
class MalwareClassifier(nn.Module):
    def __init__(self, input_dim):
        super(MalwareClassifier, self).__init__()
        # Match the exact dimensions from the saved model
        self.input_layer1 = nn.Linear(input_dim, 256)    # 630 -> 256
        self.input_layer2 = nn.Linear(256, 256)         # Changed: 256 -> 256
        
        # Create hidden layers with exact dimensions from the model
        self.hidden_layers = nn.ModuleDict({
            '2': nn.Linear(256, 128),                    # 256 -> 128
            '4': nn.Linear(128, 1)                       # 128 -> 1
        })
        
        self.dropout = nn.Dropout(0.2)

    def forward(self, x):
        # First layer: input -> 256
        x = torch.relu(self.input_layer1(x))
        x = self.dropout(x)
        
        # Second layer: 256 -> 256
        x = torch.relu(self.input_layer2(x))
        x = self.dropout(x)
        
        # Hidden layers: 256 -> 128 -> 1
        x = torch.relu(self.hidden_layers['2'](x))
        x = self.hidden_layers['4'](x)
        
        return torch.sigmoid(x)

# -----------------------------------------------------------------------------
# Model initialization with correct dimensions and error handling
# -----------------------------------------------------------------------------
INPUT_DIM = 630  # Input dimension

def get_model_path():
    """Get the correct path to the model file based on script location"""
    if getattr(sys, 'frozen', False):
        # Running as compiled executable
        base_path = os.path.dirname(sys.executable)
    else:
        # Running as script
        base_path = os.path.dirname(os.path.abspath(__file__))
    
    return os.path.join(base_path, "merged_model.pth")

# Initialize model
model = MalwareClassifier(input_dim=INPUT_DIM)

# Load model with better error handling
def load_model():
    MODEL_PATH = get_model_path()
    if not os.path.exists(MODEL_PATH):
        messagebox.showerror("Error", f"Model file not found: {MODEL_PATH}")
        return False
        
    try:
        checkpoint = torch.load(MODEL_PATH, map_location=torch.device('cpu'))
        
        # Create a new state dict with the correct dimensions
        new_state_dict = {}
        for key, value in checkpoint.items():
            if key == 'input_layer2.weight':
                # Take only the first 256 columns of the weight matrix
                new_state_dict[key] = value[:, :256]
            elif key == 'input_layer2.bias':
                new_state_dict[key] = value
            else:
                new_state_dict[key] = value
        
        # Load the modified state dict
        model.load_state_dict(new_state_dict, strict=True)
        model.eval()
        torch.set_grad_enabled(False)
        return True
    except Exception as e:
        messagebox.showerror("Error", f"Failed to load model: {str(e)}")
        return False

# -----------------------------------------------------------------------------
# Improved Feature Extraction (produces 630 features)
# -----------------------------------------------------------------------------
def extract_features(file_path):
    try:
        pe = pefile.PE(file_path, fast_load=True)
        pe.parse_data_directories()
        
        features = []
        
        # Enhanced feature extraction
        try:
            # Basic file properties
            features.append(os.path.getsize(file_path))  # File size
            
            # Header features
            features.append(pe.FILE_HEADER.Machine)
            features.append(pe.FILE_HEADER.NumberOfSections)
            features.append(pe.FILE_HEADER.SizeOfOptionalHeader)
            features.append(pe.FILE_HEADER.Characteristics)
            
            # Optional header features
            if hasattr(pe, 'OPTIONAL_HEADER'):
                opt_header = pe.OPTIONAL_HEADER
                features.extend([
                    opt_header.MajorLinkerVersion,
                    opt_header.MinorLinkerVersion,
                    opt_header.SizeOfCode,
                    opt_header.SizeOfInitializedData,
                    opt_header.SizeOfUninitializedData,
                    opt_header.AddressOfEntryPoint,
                    opt_header.BaseOfCode,
                    opt_header.ImageBase,
                    opt_header.SectionAlignment,
                    opt_header.FileAlignment,
                    opt_header.MajorOperatingSystemVersion,
                    opt_header.MinorOperatingSystemVersion,
                    opt_header.SizeOfHeaders,
                    opt_header.CheckSum,
                    opt_header.SizeOfImage
                ])
            
            # Section features with more detail
            for section in pe.sections[:15]:
                features.extend([
                    section.Misc_VirtualSize,
                    section.VirtualAddress,
                    section.SizeOfRawData,
                    section.Characteristics,
                    section.get_entropy()  # Section entropy
                ])
                
            # Import features
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                num_imports = len(pe.DIRECTORY_ENTRY_IMPORT)
                features.append(num_imports)
            else:
                features.append(0)
                
        except Exception as e:
            logging.warning(f"Some features could not be extracted: {e}")
            
        # Pad/trim to exactly 630 features
        features = features[:INPUT_DIM]
        if len(features) < INPUT_DIM:
            features += [0] * (INPUT_DIM - len(features))
            
        # Improved feature normalization
        features = torch.tensor([features], dtype=torch.float32)
        
        # Clip extreme values
        features = torch.clamp(features, -1e6, 1e6)
        
        # Z-score normalization
        features = (features - features.mean()) / (features.std() + 1e-7)
        
        return features
        
    except Exception as e:
        logging.error(f"Feature extraction failed: {e}")
        return None

# -----------------------------------------------------------------------------
# Detection Function (with improved result display)
# -----------------------------------------------------------------------------
def detect_malware(file_path):
    features = extract_features(file_path)
    if features is None:
        logging.error(f"Feature extraction failed for {file_path}")
        return False, 0.0, "Failed to extract features from file"
    
    try:
        with torch.no_grad():
            prediction = model(features)
            predicted_prob = prediction.item()
            
            # Log detailed information
            logging.info(f"File: {file_path}")
            logging.info(f"Raw prediction probability: {predicted_prob}")
            
            # More sophisticated decision logic
            high_confidence_threshold = 0.85  # Increased from 0.7
            medium_confidence_threshold = 0.65
            low_confidence_threshold = 0.5
            
            # Check if file is a known legitimate system file
            is_system_file = any(name in file_path.lower() for name in [
                'windows', 'system32', 'program files', 'microsoft'
            ])
            
            # Adjust threshold for system files
            if is_system_file:
                high_confidence_threshold = 0.95  # Higher threshold for system files
            
            if predicted_prob >= high_confidence_threshold:
                is_malware = True
                result_msg = f"⚠️ MALWARE (High Confidence: {predicted_prob:.2f})"
            elif predicted_prob >= medium_confidence_threshold:
                is_malware = True
                result_msg = f"⚠️ MALWARE (Medium Confidence: {predicted_prob:.2f})"
            elif predicted_prob >= low_confidence_threshold:
                # For borderline cases, consider additional factors
                if is_system_file:
                    is_malware = False
                    result_msg = f"✅ SAFE (System File: {1-predicted_prob:.2f})"
                else:
                    is_malware = True
                    result_msg = f"⚠️ MALWARE (Low Confidence: {predicted_prob:.2f})"
            else:
                is_malware = False
                result_msg = f"✅ SAFE (Confidence: {1-predicted_prob:.2f})"
            
            return is_malware, predicted_prob, result_msg
            
    except Exception as e:
        logging.error(f"Detection error: {e}")
        return False, 0.0, f"Error during detection: {str(e)}"

# -----------------------------------------------------------------------------
# Results class for storing scan results
# -----------------------------------------------------------------------------
class ScanResult:
    def __init__(self, file_path, is_malware, confidence, message):
        self.file_path = file_path
        self.is_malware = is_malware
        self.confidence = confidence
        self.message = message

# -----------------------------------------------------------------------------
# GUI Application
# -----------------------------------------------------------------------------
class MalwareDetectorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Advanced Malware Detector")
        self.root.geometry("600x500")
        self.setup_theme()
        self.setup_ui()
        self.results = []
        self.scanning = False
        
    def setup_theme(self):
        # Set dark theme colors
        self.bg_color = "#1e1e1e"
        self.fg_color = "#e0e0e0"
        self.accent_color = "#3d3d3d"
        self.button_bg = "#2d2d2d"
        self.button_fg = "#ffffff"
        self.highlight_color = "#007acc"  # Blue accent for highlights
        
        # Configure ttk styles for dark theme
        self.style = ttk.Style()
        self.style.theme_use("clam")
        
        # Configure colors for various widgets
        self.style.configure(".",
                    background=self.bg_color,
                    foreground=self.fg_color,
                    fieldbackground=self.bg_color,
                    troughcolor=self.accent_color)
        
        # Configure the Treeview style
        self.style.configure("Treeview", 
                    background=self.bg_color,
                    foreground=self.fg_color,
                    fieldbackground=self.bg_color)
        
        self.style.map('Treeview', 
              background=[('selected', self.highlight_color)])
              
        # Configure the root window
        self.root.configure(background=self.bg_color)
        
    def setup_ui(self):
        # Main frame
        main_frame = tk.Frame(self.root, bg=self.bg_color)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title label
        title_label = tk.Label(main_frame, text="Windows Malware Detector", 
                               font=("Arial", 16, "bold"), 
                               bg=self.bg_color, fg=self.fg_color)
        title_label.pack(pady=(0, 20))
        
        # Path selection frame
        path_frame = tk.Frame(main_frame, bg=self.bg_color)
        path_frame.pack(fill=tk.X, pady=10)
        
        path_label = tk.Label(path_frame, text="File or Folder Path:", 
                             bg=self.bg_color, fg=self.fg_color)
        path_label.pack(side=tk.LEFT, padx=(0, 5))
        
        self.entry = tk.Entry(path_frame, width=40, bg=self.accent_color, 
                             fg=self.fg_color, insertbackground=self.fg_color)
        self.entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        # Buttons frame
        button_frame = tk.Frame(main_frame, bg=self.bg_color)
        button_frame.pack(pady=10)
        
        browse_file_button = tk.Button(button_frame, text="Select File", 
                                      command=self.browse_file, 
                                      bg=self.button_bg, fg=self.button_fg,
                                      padx=10, pady=5, bd=0)
        browse_file_button.pack(side=tk.LEFT, padx=5)
        
        browse_folder_button = tk.Button(button_frame, text="Select Folder", 
                                        command=self.browse_folder, 
                                        bg=self.button_bg, fg=self.button_fg,
                                        padx=10, pady=5, bd=0)
        browse_folder_button.pack(side=tk.LEFT, padx=5)
        
        # Scan button
        self.scan_button = tk.Button(main_frame, text="Scan", 
                                   command=self.start_scan,
                                   font=("Arial", 12, "bold"), 
                                   fg="white", bg="#FF4136",
                                   padx=20, pady=5, bd=0)
        self.scan_button.pack(pady=10)
        
        # Results frame with Treeview
        results_frame = tk.Frame(main_frame, bg=self.bg_color)
        results_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        results_label = tk.Label(results_frame, text="Scan Results:", 
                                bg=self.bg_color, fg=self.fg_color)
        results_label.pack(anchor=tk.W, pady=(0, 5))
        
        # Create scrollbar and treeview
        scrollbar = tk.Scrollbar(results_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.results_tree = ttk.Treeview(results_frame, 
                                       columns=("file", "status", "confidence"),
                                       show="headings",
                                       yscrollcommand=scrollbar.set)
        
        self.results_tree.heading("file", text="File")
        self.results_tree.heading("status", text="Status")
        self.results_tree.heading("confidence", text="Confidence")
        
        # Set column widths
        self.results_tree.column("file", width=350)
        self.results_tree.column("status", width=100)
        self.results_tree.column("confidence", width=100)
        
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.results_tree.yview)
        
        # Status bar
        self.status_bar = tk.Label(self.root, text="Ready", bd=1, 
                                  relief=tk.SUNKEN, anchor=tk.W,
                                  bg=self.accent_color, fg=self.fg_color)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, 
                                           variable=self.progress_var,
                                           mode="determinate")
        self.progress_bar.pack(fill=tk.X, pady=5)
        
    def browse_file(self):
        file_path = filedialog.askopenfilename(
            filetypes=[("Executable files", "*.exe;*.dll;*.sys"), 
                      ("All files", "*.*")])
        if file_path:
            self.entry.delete(0, tk.END)
            self.entry.insert(0, file_path)
    
    def browse_folder(self):
        folder_path = filedialog.askdirectory()
        if folder_path:
            self.entry.delete(0, tk.END)
            self.entry.insert(0, folder_path)
    
    def start_scan(self):
        if self.scanning:
            messagebox.showinfo("Info", "A scan is already in progress.")
            return
            
        path = self.entry.get()
        if not path:
            messagebox.showwarning("Warning", "Please select a file or folder to scan.")
            return
            
        # Clear previous results
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        self.results = []
        
        # Start scan in a separate thread
        self.scanning = True
        self.scan_button.config(text="Scanning...", state=tk.DISABLED)
        scan_thread = threading.Thread(target=self.scan_path, args=(path,))
        scan_thread.daemon = True
        scan_thread.start()
    
    def scan_path(self, path):
        try:
            if os.path.isfile(path):
                self.scan_file(path)
            elif os.path.isdir(path):
                self.scan_folder(path)
            else:
                self.update_status("Error: Invalid file or folder path.")
        finally:
            self.root.after(0, self.finalize_scan)
    
    def scan_file(self, file_path):
        self.update_status(f"Scanning: {file_path}")
        is_malware, confidence, message = detect_malware(file_path)
        result = ScanResult(file_path, is_malware, confidence, message)
        self.results.append(result)
        self.root.after(0, lambda: self.add_result_to_tree(result))
    
    def scan_folder(self, folder_path):
        # Get list of all files first
        all_files = []
        for root_dir, _, files in os.walk(folder_path):
            for file in files:
                if file.lower().endswith(('.exe', '.dll', '.sys')):
                    all_files.append(os.path.join(root_dir, file))
        
        total_files = len(all_files)
        if total_files == 0:
            self.update_status("No executable files found in the folder.")
            return
            
        # Process each file with progress update
        for i, file_path in enumerate(all_files):
            self.update_status(f"Scanning ({i+1}/{total_files}): {file_path}")
            self.update_progress((i+1)/total_files * 100)
            is_malware, confidence, message = detect_malware(file_path)
            result = ScanResult(file_path, is_malware, confidence, message)
            self.results.append(result)
            self.root.after(0, lambda r=result: self.add_result_to_tree(r))
    
    def add_result_to_tree(self, result):
        status = "⚠️ MALWARE" if result.is_malware else "✅ SAFE"
        confidence = f"{result.confidence:.2f}" if result.is_malware else f"{1-result.confidence:.2f}"
        self.results_tree.insert("", tk.END, values=(result.file_path, status, confidence))
    
    def update_status(self, message):
        self.root.after(0, lambda: self.status_bar.config(text=message))
    
    def update_progress(self, value):
        self.root.after(0, lambda: self.progress_var.set(value))
    
    def finalize_scan(self):
        self.scanning = False
        self.scan_button.config(text="Scan", state=tk.NORMAL)
        self.update_status("Scan completed")
        self.update_progress(0)
        
        # Show summary
        malware_count = sum(1 for r in self.results if r.is_malware)
        total_count = len(self.results)
        if total_count > 0:
            messagebox.showinfo("Scan Complete", 
                              f"Scan completed! Found {malware_count} malicious files out of {total_count} scanned.")

# -----------------------------------------------------------------------------
# Application Startup
# -----------------------------------------------------------------------------
def main():
    root = tk.Tk()
    
    # Check if model loads successfully
    if load_model():
        app = MalwareDetectorApp(root)
        root.mainloop()
    else:
        sys.exit(1)

if __name__ == "__main__":
    main()