import tkinter as tk
from tkinter import messagebox, ttk
import joblib
import os
import numpy as np
import pandas as pd
import hashlib
import math
import re
import psutil
import threading
import time
import platform

def analyze_model_files():
    """Analyze the model and scaler files to determine expected features"""
    try:
        # Load the trained model and feature scaler
        model = joblib.load(model_path)
        scaler = joblib.load(scaler_path)
        
        # Extract feature information
        expected_features = scaler.n_features_in_
        feature_names = scaler.feature_names_in_
        
        print(f"Model loaded successfully. Expected features: {expected_features}")
        print(f"Feature names sample: {feature_names[:5]}...")
        
        return model, scaler, expected_features, feature_names
    except Exception as e:
        messagebox.showerror("Error", f"Failed to load model files: {e}")
        return None, None, 0, []

def calculate_entropy(data):
    """Calculate Shannon entropy of binary data"""
    if not data:
        return 0
    
    byte_counts = {}
    for byte in data:
        byte_counts[byte] = byte_counts.get(byte, 0) + 1
    
    entropy = 0
    for count in byte_counts.values():
        probability = count / len(data)
        entropy -= probability * math.log2(probability)
    
    return entropy

def extract_process_features(process, feature_names):
    """Extract features from a running process"""
    try:
        # Basic process information
        process_info = {
            'file_size': 0,
            'entropy': 0,
            'is_executable': 1,  # All processes are executable
            'uses_networking': 0,
            'total_api_calls': 0,
            'unique_api_calls': 0,
            'found_apis': [],
            'md5_hash': '',
            'sha1_hash': '',
            'file_type': 'Process',
            'file_mime': 'application/x-executable'
        }
        
        # Get process executable path
        try:
            exe_path = process.exe()
            if os.path.exists(exe_path):
                process_info['file_size'] = os.path.getsize(exe_path)
                
                # Read a small portion of the executable for analysis
                with open(exe_path, 'rb') as f:
                    content = f.read(min(1024*1024, process_info['file_size']))  # Read up to 1MB
                
                process_info['entropy'] = calculate_entropy(content)
                process_info['md5_hash'] = hashlib.md5(content).hexdigest()
                process_info['sha1_hash'] = hashlib.sha1(content).hexdigest()
                
                # Extract strings and analyze
                try:
                    strings = re.findall(b'[\\x20-\\x7E]{5,}', content)
                    decoded_strings = [s.decode('utf-8', errors='ignore') for s in strings]
                    
                    # Check for network-related strings
                    network_related = any(net_term in ' '.join(decoded_strings).lower() 
                                        for net_term in ['http://', 'https://', 'socket', 'connect', 'recv', 'send'])
                    
                    process_info['uses_networking'] = int(network_related)
                    
                    # Count potential API calls
                    process_info['total_api_calls'] = sum(1 for s in decoded_strings if s.endswith('A') or s.endswith('W'))
                    process_info['unique_api_calls'] = len(set(s for s in decoded_strings if s.endswith('A') or s.endswith('W')))
                    
                    # Look for common Windows API calls
                    common_apis = ['CreateFile', 'ReadFile', 'WriteFile', 'RegOpenKey', 'Socket', 
                                  'Connect', 'Send', 'Recv', 'CreateProcess', 'VirtualAlloc']
                    process_info['found_apis'] = [api for api in common_apis if any(api in s for s in decoded_strings)]
                    
                except Exception as e:
                    print(f"Error during string analysis: {e}")
        except:
            # If we can't access the executable, use what we know
            pass
        
        # Check network connections
        if not process_info['uses_networking']:
            try:
                connections = process.connections()
                process_info['uses_networking'] = int(len(connections) > 0)
            except:
                pass
        
        # Map extracted features to the feature space expected by the model
        feature_dict = {name: 0 for name in feature_names}
        
        # Map extracted features to expected feature names
        for name in feature_names:
            if name in process_info:
                feature_dict[name] = process_info[name]
            
            # Handle API-related features
            elif name.startswith('api_') and 'found_apis' in process_info:
                # Check if any of our found APIs are related to this feature
                for api in process_info['found_apis']:
                    # Create a simple hash of the API name to compare with feature name
                    api_hash = hashlib.md5(api.encode()).hexdigest()
                    if api_hash[:10] in name:
                        feature_dict[name] = 1
                        break
                        
            # Handle accessed file types
            elif name == 'accessed_file_types':
                feature_dict[name] = 1  # Processes always access executables
        
        # Set network-related features
        if process_info['uses_networking']:
            for name in feature_names:
                if any(term in name.lower() for term in ['network', 'connect', 'socket', 'http']):
                    feature_dict[name] = 1
        
        # Convert to DataFrame to ensure correct order
        features_df = pd.DataFrame([feature_dict])
        
        return features_df, process_info
    except Exception as e:
        print(f"Error extracting features for process {process.name()}: {e}")
        return None, {}

def scan_process(process):
    """Scan a single process and return the result"""
    try:
        features_df, process_info = extract_process_features(process, feature_names)
        if features_df is not None:
            features_scaled = scaler.transform(features_df)
            prediction = model.predict(features_scaled)[0]
            
            # Get probability if available
            confidence = 0.0
            if hasattr(model, 'predict_proba'):
                probs = model.predict_proba(features_scaled)[0]
                confidence = probs[1] if prediction == 1 else probs[0]
                confidence *= 100
            
            label = "Suspicious" if prediction == 1 else "Safe"
            return process.name(), process.pid, process.exe() if hasattr(process, 'exe') else "Unknown", label, confidence, process_info
        return process.name(), process.pid, "Unknown", "Error", 0, {}
    except Exception as e:
        return str(process), 0, "Unknown", f"Error: {str(e)}", 0, {}

def scan_background_processes():
    """Scan all running processes"""
    # Clear previous results
    for item in result_tree.get_children():
        result_tree.delete(item)
    
    # Get all processes
    processes = list(psutil.process_iter(['pid', 'name', 'exe']))
    
    # Configure progress bar
    progress["value"] = 0
    progress["maximum"] = len(processes)
    root.update()
    
    # Update status
    status_label.config(text=f"Scanning {len(processes)} processes...")
    
    for i, process in enumerate(processes):
        try:
            name, pid, exe_path, label, confidence, _ = scan_process(process)
            
            # Update UI
            tag = "suspicious" if label == "Suspicious" else "safe"
            result_tree.insert("", "end", values=(name, pid, exe_path, label, f"{confidence:.2f}%"), tags=(tag,))
            
            # Update progress
            progress["value"] = i + 1
            status_label.config(text=f"Scanning: {i+1}/{len(processes)}")
            root.update()
            
        except Exception as e:
            print(f"Error scanning process: {e}")
    
    status_label.config(text=f"Scan complete. {len(processes)} processes scanned.")

def start_scan_thread():
    """Start scanning processes in a background thread"""
    threading.Thread(target=scan_background_processes, daemon=True).start()

def auto_refresh_scan():
    """Toggle automatic refresh of the process scan"""
    global auto_refresh
    auto_refresh = not auto_refresh
    refresh_button.config(text="Stop Auto-Refresh" if auto_refresh else "Enable Auto-Refresh")
    
    if auto_refresh:
        schedule_refresh()

def schedule_refresh():
    """Schedule the next refresh if auto-refresh is enabled"""
    if auto_refresh:
        start_scan_thread()
        root.after(refresh_interval_ms, schedule_refresh)

def create_gui():
    global result_tree, progress, status_label, root, refresh_button, auto_refresh, refresh_interval_ms
    
    # Initialize auto-refresh settings
    auto_refresh = False
    refresh_interval_ms = 30000  # 30 seconds
    
    root = tk.Tk()
    root.title("Process Malware Scanner")
    root.geometry("1000x700")
    
    # Set dark theme colors
    bg_color = "#1e1e1e"
    fg_color = "#e0e0e0"
    accent_color = "#3d3d3d"
    button_bg = "#2d2d2d"
    button_fg = "#ffffff"
    
    # Configure ttk styles for dark theme
    style = ttk.Style()
    style.theme_use("clam")  # Use clam as base theme
    
    # Configure colors for various widgets
    style.configure(".", 
                   background=bg_color, 
                   foreground=fg_color, 
                   fieldbackground=bg_color,
                   troughcolor=accent_color)
    
    # Button style
    style.configure("TButton", 
                   background=button_bg, 
                   foreground=button_fg, 
                   borderwidth=1, 
                   focusthickness=0, 
                   focuscolor=accent_color)
    style.map("TButton",
             background=[("active", "#4d4d4d"), ("pressed", "#5a5a5a")],
             foreground=[("active", "#ffffff")])
    
    # Frame style
    style.configure("TFrame", background=bg_color)
    
    # LabelFrame style
    style.configure("TLabelframe", 
                   background=bg_color, 
                   foreground=fg_color)
    style.configure("TLabelframe.Label", 
                   background=bg_color, 
                   foreground=fg_color)
    
    # Label style
    style.configure("TLabel", 
                   background=bg_color, 
                   foreground=fg_color)
    
    # Progressbar style
    style.configure("Horizontal.TProgressbar", 
                   background="#007acc", 
                   troughcolor=accent_color)
    
    # Treeview style - this is for the background of the treeview
    style.configure("Treeview", 
                   background="#2d2d2d", 
                   foreground=fg_color, 
                   fieldbackground="#2d2d2d")
    style.map("Treeview", 
             background=[("selected", "#007acc")],
             foreground=[("selected", "#ffffff")])
    
    # Configure treeview header
    style.configure("Treeview.Heading", 
                   background=accent_color, 
                   foreground=fg_color,
                   relief="flat")
    style.map("Treeview.Heading",
             background=[("active", "#4d4d4d")])
    
    # Configure scrollbar
    style.configure("Vertical.TScrollbar", 
                   background=accent_color, 
                   troughcolor=bg_color,
                   arrowcolor=fg_color)
    style.configure("Horizontal.TScrollbar", 
                   background=accent_color, 
                   troughcolor=bg_color,
                   arrowcolor=fg_color)
    
    # Configure the root window
    root.configure(background=bg_color)
    
    # Main frame
    main_frame = ttk.Frame(root, padding="10")
    main_frame.pack(fill=tk.BOTH, expand=True)
    
    # Button frame
    button_frame = ttk.Frame(main_frame)
    button_frame.pack(fill=tk.X, pady=10)
    
    scan_button = ttk.Button(button_frame, text="Scan Processes", command=start_scan_thread)
    scan_button.pack(side=tk.LEFT, padx=5)
    
    refresh_button = ttk.Button(button_frame, text="Enable Auto-Refresh", command=auto_refresh_scan)
    refresh_button.pack(side=tk.LEFT, padx=5)
    
    # Progress bar
    progress_frame = ttk.Frame(main_frame)
    progress_frame.pack(fill=tk.X, pady=5)
    
    progress = ttk.Progressbar(progress_frame, orient=tk.HORIZONTAL, length=100, mode='determinate')
    progress.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    status_label = ttk.Label(progress_frame, text="Ready")
    status_label.pack(side=tk.RIGHT, padx=5)
    
    # Results tree
    tree_frame = ttk.Frame(main_frame)
    tree_frame.pack(fill=tk.BOTH, expand=True, pady=10)
    
    columns = ("name", "pid", "path", "status", "confidence")
    result_tree = ttk.Treeview(tree_frame, columns=columns, show="headings")
    
    # Define headings
    result_tree.heading("name", text="Process Name")
    result_tree.heading("pid", text="PID")
    result_tree.heading("path", text="Executable Path")
    result_tree.heading("status", text="Status")
    result_tree.heading("confidence", text="Confidence")
    
    # Define columns
    result_tree.column("name", width=150)
    result_tree.column("pid", width=80)
    result_tree.column("path", width=400)
    result_tree.column("status", width=100)
    result_tree.column("confidence", width=100)
    
    # Configure tags for colors (dark theme versions)
    result_tree.tag_configure("suspicious", background="#6b2b2b")  # Dark red for suspicious
    result_tree.tag_configure("safe", background="#2b4f2b")  # Dark green for safe
    
    # Add scrollbars
    y_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=result_tree.yview)
    result_tree.configure(yscroll=y_scrollbar.set)
    y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    x_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=result_tree.xview)
    result_tree.configure(xscroll=x_scrollbar.set)
    x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
    
    result_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    
    # Add process details panel
    details_frame = ttk.LabelFrame(main_frame, text="Process Details")
    details_frame.pack(fill=tk.X, pady=10)
    
    # Text widget for details (needs special treatment for dark theme)
    details_text = tk.Text(details_frame, height=8, wrap=tk.WORD, 
                         bg="#2d2d2d", fg=fg_color, 
                         insertbackground=fg_color,  # Cursor color
                         selectbackground="#007acc",  # Selection background
                         selectforeground=fg_color,  # Selection text color
                         relief="flat",
                         padx=5, pady=5)
    details_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
    
    # Scrollbar for details
    details_scrollbar = ttk.Scrollbar(details_frame, orient=tk.VERTICAL, command=details_text.yview)
    details_text.configure(yscrollcommand=details_scrollbar.set)
    details_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    # Show details when clicking on a process
    def show_process_details(event):
        selected_items = result_tree.selection()
        if not selected_items:
            return
            
        selected_item = selected_items[0]
        values = result_tree.item(selected_item, 'values')
        
        if values:
            try:
                process_name = values[0]
                process_pid = int(values[1])
                
                # Get detailed process info
                try:
                    process = psutil.Process(process_pid)
                    
                    # Clear previous details
                    details_text.delete(1.0, tk.END)
                    
                    # Add process information
                    details = [
                        f"Name: {process.name()}",
                        f"PID: {process.pid}",
                        f"Executable: {process.exe()}",
                        f"Status: {process.status()}",
                        f"CPU Usage: {process.cpu_percent()}%",
                        f"Memory Usage: {process.memory_info().rss / (1024 * 1024):.2f} MB",
                        f"Created: {time.ctime(process.create_time())}",
                        f"Command Line: {' '.join(process.cmdline())}"
                    ]
                    
                    # Add network connections
                    try:
                        connections = process.connections()
                        if connections:
                            details.append("\nNetwork Connections:")
                            for conn in connections:
                                local = f"{conn.laddr.ip}:{conn.laddr.port}" if hasattr(conn, 'laddr') and conn.laddr else "N/A"
                                remote = f"{conn.raddr.ip}:{conn.raddr.port}" if hasattr(conn, 'raddr') and conn.raddr else "N/A"
                                details.append(f"  {conn.status}: {local} -> {remote}")
                    except:
                        details.append("\nCould not retrieve network connections.")
                    
                    # Add open files
                    try:
                        open_files = process.open_files()
                        if open_files:
                            details.append("\nOpen Files:")
                            for file in open_files[:10]:  # Limit to first 10
                                details.append(f"  {file.path}")
                            if len(open_files) > 10:
                                details.append(f"  ... and {len(open_files) - 10} more")
                    except:
                        details.append("\nCould not retrieve open files.")
                    
                    details_text.insert(tk.END, "\n".join(details))
                    
                except psutil.NoSuchProcess:
                    details_text.delete(1.0, tk.END)
                    details_text.insert(tk.END, f"Process {process_pid} no longer exists.")
                except Exception as e:
                    details_text.delete(1.0, tk.END)
                    details_text.insert(tk.END, f"Error getting process details: {str(e)}")
            except:
                details_text.delete(1.0, tk.END)
                details_text.insert(tk.END, "Unable to get process details.")
    
    result_tree.bind('<<TreeviewSelect>>', show_process_details)
    
    # Add termination button for suspicious processes
    def terminate_selected_process():
        selected_items = result_tree.selection()
        if not selected_items:
            messagebox.showinfo("Info", "No process selected")
            return
            
        selected_item = selected_items[0]
        values = result_tree.item(selected_item, 'values')
        
        if values:
            try:
                process_name = values[0]
                process_pid = int(values[1])
                
                # Confirm termination
                if messagebox.askyesno("Confirm", f"Are you sure you want to terminate process '{process_name}' (PID: {process_pid})?"):
                    try:
                        process = psutil.Process(process_pid)
                        process.terminate()
                        messagebox.showinfo("Success", f"Termination signal sent to process {process_name}")
                        # Remove from tree
                        result_tree.delete(selected_item)
                    except psutil.NoSuchProcess:
                        messagebox.showinfo("Info", f"Process {process_pid} no longer exists")
                    except psutil.AccessDenied:
                        messagebox.showerror("Error", f"Access denied when trying to terminate process {process_name}")
                    except Exception as e:
                        messagebox.showerror("Error", f"Failed to terminate process: {str(e)}")
            except:
                messagebox.showerror("Error", "Unable to get process details.")
    
    terminate_button = ttk.Button(button_frame, text="Terminate Selected Process", command=terminate_selected_process)
    terminate_button.pack(side=tk.LEFT, padx=5)
    
    # Customize message box appearance (for future message boxes)
    root.option_add('*Dialog.msg.background', bg_color)
    root.option_add('*Dialog.msg.foreground', fg_color)
    root.option_add('*Dialog.background', bg_color)
    root.option_add('*Dialog.foreground', fg_color)
    root.option_add('*Dialog.Button.background', button_bg)
    root.option_add('*Dialog.Button.foreground', button_fg)
    
    # Start initial scan
    root.after(1000, start_scan_thread)
    
    root.mainloop()

if __name__ == "__main__":
    # Define paths relative to the script location
    script_dir = os.path.dirname(os.path.abspath(__file__))
    model_path = os.path.join(script_dir, "model.joblib")
    scaler_path = os.path.join(script_dir, "feature_scaler.joblib")
    
    # Check if psutil is installed
    try:
        import psutil
    except ImportError:
        messagebox.showerror("Error", "The psutil module is required but not installed. Please install it using: pip install psutil")
        exit(1)
    
    # Analyze model files to get expected features
    model, scaler, expected_features, feature_names = analyze_model_files()
    
    if model is not None:
        create_gui()
    else:
        print("Failed to initialize the application due to model loading errors.")