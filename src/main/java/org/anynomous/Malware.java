package main.java.org.anynomous;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Stream;

public class Malware extends JPanel {

    // Define colors
    private static final Color PRIMARY_DARK = new Color(17, 24, 39);
    private static final Color SECONDARY_DARK = new Color(31, 41, 55);
    private static final Color ACCENT_COLOR = new Color(59, 130, 246);
    private static final Color ACCENT_HOVER = new Color(96, 165, 250);
    private static final Color TEXT_PRIMARY = new Color(243, 244, 246);

    // Define fonts
    private static final Font BUTTON_FONT = new Font("Inter", Font.BOLD, 14);
    private static final Font LOG_FONT = new Font("JetBrains Mono", Font.PLAIN, 13);

    // ML Model for file scanning
    private final MLModel mlModel;

    // Folder scanner log area
    private JTextArea logArea;

    // Process scanner components
    private JTable processTable;
    private DefaultTableModel processTableModel;

    public Malware() {
        mlModel = new MLModel();
        setupMainPanel();
        createLayout();
        loadPretrainedModel();
    }

    private void setupMainPanel() {
        setBackground(PRIMARY_DARK);
        setLayout(new BorderLayout(32, 32));
        setBorder(new EmptyBorder(32, 32, 32, 32));
    }

    private void createLayout() {
        // Create a tabbed pane for Process and Folder scanning
        JTabbedPane tabbedPane = new JTabbedPane();

        // Process Scanner Tab
        JPanel processScannerPanel = createProcessScannerPanel();
        tabbedPane.addTab("Process Scanner", processScannerPanel);

        // Folder Scanner Tab
        JPanel folderScannerPanel = createFolderScannerPanel();
        tabbedPane.addTab("Folder Scanner", folderScannerPanel);

        add(tabbedPane, BorderLayout.CENTER);
    }

    // Create the Process Scanner panel with a table and control buttons
    private JPanel createProcessScannerPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(PRIMARY_DARK);

        // Table for process listing
        processTableModel = new DefaultTableModel(new Object[]{"PID", "Name", "Status"}, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        processTable = new JTable(processTableModel);
        processTable.setFillsViewportHeight(true);
        JScrollPane tableScroll = new JScrollPane(processTable);
        panel.add(tableScroll, BorderLayout.CENTER);

        // Control buttons at the bottom
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 24, 16));
        buttonPanel.setBackground(SECONDARY_DARK);
        JButton refreshButton = createButton("Refresh Processes", e -> refreshProcessList(), ACCENT_COLOR, ACCENT_HOVER);
        JButton scanButton = createButton("Scan Processes", e -> scanProcesses(), ACCENT_COLOR, ACCENT_HOVER);
        buttonPanel.add(refreshButton);
        buttonPanel.add(scanButton);
        panel.add(buttonPanel, BorderLayout.SOUTH);

        // Populate the process list initially
        refreshProcessList();

        return panel;
    }

    // Create the Folder Scanner panel with a log area and scan button
    private JPanel createFolderScannerPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(PRIMARY_DARK);

        // Top control panel with a "Scan Folder" button
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 24, 16));
        controlPanel.setBackground(SECONDARY_DARK);
        JButton scanButton = createButton("Scan Folder", e -> selectFolder(), ACCENT_COLOR, ACCENT_HOVER);
        controlPanel.add(scanButton);
        panel.add(controlPanel, BorderLayout.NORTH);

        // Log area to display scanning output
        logArea = new JTextArea();
        logArea.setBackground(PRIMARY_DARK);
        logArea.setForeground(TEXT_PRIMARY);
        logArea.setFont(LOG_FONT);
        logArea.setEditable(false);
        logArea.setBorder(new EmptyBorder(8, 8, 8, 8));
        JScrollPane scrollPane = new JScrollPane(logArea);
        scrollPane.setBorder(null);
        panel.add(scrollPane, BorderLayout.CENTER);

        return panel;
    }

    // Create a custom-styled button
    private JButton createButton(String text, ActionListener action, Color bgColor, Color hoverColor) {
        JButton button = new JButton(text) {
            @Override
            protected void paintComponent(Graphics g) {
                Graphics2D g2d = (Graphics2D) g;
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                g2d.setColor(getBackground());
                g2d.fillRoundRect(0, 0, getWidth(), getHeight(), 12, 12);
                super.paintComponent(g);
            }
        };

        button.setFont(BUTTON_FONT);
        button.setForeground(TEXT_PRIMARY);
        button.setBackground(bgColor);
        button.setBorderPainted(false);
        button.setFocusPainted(false);
        button.setContentAreaFilled(false);
        button.setPreferredSize(new Dimension(220, 44));

        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                button.setBackground(hoverColor);
                button.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }
            @Override
            public void mouseExited(MouseEvent e) {
                button.setBackground(bgColor);
            }
        });
        button.addActionListener(action);
        return button;
    }

    // Load the pretrained model (for file scanning) with a simulated delay
    private void loadPretrainedModel() {
        appendLog("Loading pretrained ML model...");
        try {
            Thread.sleep(1000);
            mlModel.loadModel();
            appendLog("Pretrained model loaded successfully.\n");
        } catch (Exception e) {
            appendLog("Error loading model: " + e.getMessage());
        }
    }

    // Append text to the log area
    private void appendLog(String text) {
        if (logArea != null) {
            logArea.append(text + "\n");
        }
    }

    // ------------------ Folder Scanning Methods ------------------

    // Prompt user to select a folder and then start scanning it
    private void selectFolder() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Select Folder to Scan");
        fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File folder = fileChooser.getSelectedFile();
            scanFolder(folder);
        }
    }

    // Scan the selected folder using a SwingWorker
    private void scanFolder(File folder) {
        appendLog("Starting scan of folder: " + folder.getPath());

        SwingWorker<List<ScanResult>, String> worker = new SwingWorker<>() {
            @Override
            protected List<ScanResult> doInBackground() {
                List<ScanResult> results = new ArrayList<>();
                publish("Scanning folder contents...");
                try (Stream<Path> paths = Files.walk(folder.toPath())) {
                    paths.filter(Files::isRegularFile).forEach(path -> {
                        publish("Scanning: " + path.getFileName());
                        results.add(mlModel.analyzeFile(path.toFile()));
                    });
                } catch (IOException e) {
                    publish("Error walking directory: " + e.getMessage());
                }
                return results;
            }

            @Override
            protected void process(List<String> chunks) {
                for (String msg : chunks) {
                    appendLog(msg);
                }
            }

            @Override
            protected void done() {
                try {
                    List<ScanResult> results = get();
                    displayFolderResults(results);
                } catch (Exception e) {
                    appendLog("Error completing scan: " + e.getMessage());
                }
            }
        };

        worker.execute();
    }

    // Display the results of the folder scan in the log area
    private void displayFolderResults(List<ScanResult> results) {
        StringBuilder sb = new StringBuilder();
        sb.append("\n=== Folder Scan Summary ===\n");
        sb.append("Total files scanned: ").append(results.size()).append("\n");

        long suspiciousFiles = results.stream()
                .filter(r -> r.classification.equals("suspicious"))
                .count();
        sb.append("Suspicious files found: ").append(suspiciousFiles).append("\n");
        sb.append("=========================\n\n");

        if (suspiciousFiles > 0) {
            sb.append("Suspicious files:\n");
            results.stream()
                    .filter(r -> r.classification.equals("suspicious"))
                    .forEach(r -> {
                        sb.append("- ").append(r.fileName).append("\n");
                        sb.append("  Risk Score: ").append(String.format("%.2f%%", r.riskScore * 100)).append("\n");
                    });
        }
        appendLog(sb.toString());
    }

    // ------------------ Process Scanning Methods ------------------

    // Refresh the process list using Java's ProcessHandle API (Java 9+)
    private void refreshProcessList() {
        processTableModel.setRowCount(0);
        ProcessHandle.allProcesses().forEach(ph -> {
            Optional<String> command = ph.info().command();
            String name = command.orElse("Unknown");
            // Display only the file name (if available)
            name = new File(name).getName();
            processTableModel.addRow(new Object[]{ph.pid(), name, "Unknown"});
        });
    }

    // Scan processes by checking the process name for suspicious keywords
    private void scanProcesses() {
        SwingWorker<Void, String> worker = new SwingWorker<>() {
            @Override
            protected Void doInBackground() throws Exception {
                int rowCount = processTableModel.getRowCount();
                for (int i = 0; i < rowCount; i++) {
                    Long pid = (Long) processTableModel.getValueAt(i, 0);
                    String name = (String) processTableModel.getValueAt(i, 1);
                    boolean malicious = predictMaliciousForProcess(name);
                    String status = malicious ? "Malicious" : "Safe";
                    processTableModel.setValueAt(status, i, 2);
                    publish("Scanned process: " + name + " -> " + status);
                    Thread.sleep(100); // Simulate a scanning delay
                }
                return null;
            }

            @Override
            protected void process(List<String> chunks) {
                // Optionally, append process scan messages to the folder scanner log
                for (String msg : chunks) {
                    appendLog(msg);
                }
            }
        };
        worker.execute();
    }

    // A simple prediction method for process names
    private boolean predictMaliciousForProcess(String processName) {
        String lowerName = processName.toLowerCase();
        String[] suspiciousKeywords = {"mal", "susp", "hack", "virus"};
        for (String keyword : suspiciousKeywords) {
            if (lowerName.contains(keyword)) {
                return true;
            }
        }
        // Otherwise, simulate randomness
        return ThreadLocalRandom.current().nextBoolean();
    }

    // ------------------ ML Model and Result Classes ------------------

    // MLModel simulates loading a pretrained model and analyzing a file.
    private static class MLModel {
        private static final String MODEL_PATH = "malware_classifier.pth";
        private boolean modelLoaded = false;
        private static final Set<String> SUSPICIOUS_PATTERNS = new HashSet<>(Arrays.asList(
                "CreateRemoteThread",
                "VirtualAlloc",
                "WriteProcessMemory",
                "LoadLibrary",
                "WinExec",
                "CreateProcess",
                "ShellExecute"
        ));

        public void loadModel() {
            System.out.println("Loading model from: " + MODEL_PATH);
            try {
                Thread.sleep(500); // Simulate delay in loading the model
            } catch (InterruptedException e) {
                // Handle interruption if needed
            }
            modelLoaded = true;
        }

        public ScanResult analyzeFile(File file) {
            if (!modelLoaded) {
                return new ScanResult(file.getName(), file.length(), 0, false, 0, 0, "error - model not loaded");
            }
            try {
                byte[] content = Files.readAllBytes(file.toPath());
                double entropy = calculateEntropy(content);
                boolean hasExecHeader = checkExecutableHeader(content);
                int suspiciousPatterns = detectSuspiciousPatterns(content);
                double riskScore = calculateRiskScore(entropy, hasExecHeader, suspiciousPatterns, content.length);
                String classification = riskScore > 0.5 ? "suspicious" : "safe";
                return new ScanResult(
                        file.getName(),
                        file.length(),
                        entropy,
                        hasExecHeader,
                        suspiciousPatterns,
                        riskScore,
                        classification
                );
            } catch (IOException e) {
                return new ScanResult(file.getName(), file.length(), 0, false, 0, 0, "error");
            }
        }

        private double calculateEntropy(byte[] data) {
            int[] frequencies = new int[256];
            for (byte b : data) {
                frequencies[b & 0xFF]++;
            }
            double entropy = 0;
            for (int frequency : frequencies) {
                if (frequency > 0) {
                    double probability = (double) frequency / data.length;
                    entropy -= probability * (Math.log(probability) / Math.log(2));
                }
            }
            return entropy;
        }

        private boolean checkExecutableHeader(byte[] data) {
            if (data.length < 2) return false;
            // Windows MZ header
            if (data[0] == 0x4D && data[1] == 0x5A) return true;
            // Linux ELF header
            if (data.length >= 4 &&
                    data[0] == 0x7F &&
                    data[1] == 0x45 &&
                    data[2] == 0x4C &&
                    data[3] == 0x46) return true;
            // Mach-O header (macOS)
            if (data.length >= 4 &&
                    ((data[0] == (byte)0xFE && data[1] == (byte)0xED && data[2] == (byte)0xFA && data[3] == (byte)0xCE) ||
                            (data[0] == (byte)0xCE && data[1] == (byte)0xFA && data[2] == (byte)0xED && data[3] == (byte)0xFE))) {
                return true;
            }
            return false;
        }

        private int detectSuspiciousPatterns(byte[] data) {
            try {
                String content = new String(data, "UTF-8");
                return (int) SUSPICIOUS_PATTERNS.stream()
                        .filter(pattern -> content.contains(pattern))
                        .count();
            } catch (Exception e) {
                return 0;
            }
        }

        private double calculateRiskScore(double entropy, boolean hasExecHeader, int suspiciousPatterns, long fileSize) {
            double score = 0.0;
            // Entropy analysis: high entropy may indicate packing/encryption
            if (entropy > 7.0) score += 0.3;
            else if (entropy > 6.0) score += 0.15;
            // Executable header presence
            if (hasExecHeader) score += 0.2;
            // Suspicious API patterns (max 0.3)
            score += Math.min(0.3, suspiciousPatterns * 0.1);
            // File size analysis for executables
            if (hasExecHeader) {
                if (fileSize < 1024) score += 0.1;
                if (fileSize > 50 * 1024 * 1024) score += 0.1;
            }
            return Math.min(1.0, score);
        }
    }

    // ScanResult holds the result of scanning a file.
    private static class ScanResult {
        public final String fileName;
        public final long fileSize;
        public final double entropy;
        public final boolean hasExecutableHeader;
        public final int suspiciousPatterns;
        public final double riskScore;
        public final String classification;

        public ScanResult(String fileName, long fileSize, double entropy,
                          boolean hasExecutableHeader, int suspiciousPatterns,
                          double riskScore, String classification) {
            this.fileName = fileName;
            this.fileSize = fileSize;
            this.entropy = entropy;
            this.hasExecutableHeader = hasExecutableHeader;
            this.suspiciousPatterns = suspiciousPatterns;
            this.riskScore = riskScore;
            this.classification = classification;
        }
    }

    // Main method to run the application
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Malware Scanner");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setContentPane(new Malware());
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }
}
