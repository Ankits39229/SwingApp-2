package main.java.org.anynomous;

import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.List;

public class Malware extends JPanel {

    private static final Color PRIMARY_DARK = new Color(17, 24, 39);
    private static final Color SECONDARY_DARK = new Color(31, 41, 55);
    private static final Color ACCENT_COLOR = new Color(59, 130, 246);
    private static final Color ACCENT_HOVER = new Color(96, 165, 250);
    private static final Color TEXT_PRIMARY = new Color(243, 244, 246);

    private static final Font BUTTON_FONT = new Font("Inter", Font.BOLD, 14);
    private static final Font LOG_FONT = new Font("JetBrains Mono", Font.PLAIN, 13);

    private JTextArea logArea;
    private final MLModel mlModel;

    public Malware() {
        mlModel = new MLModel();
        setupMainPanel();
        createLayout();
        loadPretrainedModel();
    }

    private void setupMainPanel() {
        setBackground(PRIMARY_DARK);
        setLayout(new BorderLayout(32, 32));
        setBorder(new EmptyBorder(32, 32, 32, 32));
    }

    private void createLayout() {
        JPanel mainContent = new JPanel();
        mainContent.setLayout(new BoxLayout(mainContent, BoxLayout.Y_AXIS));
        mainContent.setBackground(PRIMARY_DARK);

        mainContent.add(createControlPanel());
        mainContent.add(Box.createRigidArea(new Dimension(0, 24)));
        mainContent.add(createLogPanel());

        add(mainContent, BorderLayout.CENTER);
    }

    private JPanel createControlPanel() {
        JPanel controlPanel = new JPanel();
        controlPanel.setBackground(SECONDARY_DARK);
        controlPanel.setBorder(new EmptyBorder(16, 16, 16, 16));
        controlPanel.setLayout(new FlowLayout(FlowLayout.CENTER, 24, 16));

        JButton scanButton = createButton("Scan", e -> selectFolder(), ACCENT_COLOR, ACCENT_HOVER);

        controlPanel.add(scanButton);

        return controlPanel;
    }

    private JPanel createLogPanel() {
        JPanel logPanel = new JPanel(new BorderLayout());
        logPanel.setBackground(SECONDARY_DARK);
        logPanel.setBorder(new EmptyBorder(16, 16, 16, 16));

        logArea = new JTextArea();
        logArea.setBackground(PRIMARY_DARK);
        logArea.setForeground(TEXT_PRIMARY);
        logArea.setFont(LOG_FONT);
        logArea.setEditable(false);
        logArea.setBorder(new EmptyBorder(8, 8, 8, 8));

        JScrollPane scrollPane = new JScrollPane(logArea);
        scrollPane.setBorder(null);

        logPanel.add(scrollPane, BorderLayout.CENTER);

        return logPanel;
    }

    private JButton createButton(String text, ActionListener action, Color bgColor, Color hoverColor) {
        JButton button = new JButton(text) {
            @Override
            protected void paintComponent(Graphics g) {
                Graphics2D g2d = (Graphics2D) g;
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                g2d.setColor(getBackground());
                g2d.fillRoundRect(0, 0, getWidth(), getHeight(), 12, 12);
                super.paintComponent(g);
            }
        };

        button.setFont(BUTTON_FONT);
        button.setForeground(TEXT_PRIMARY);
        button.setBackground(bgColor);
        button.setBorderPainted(false);
        button.setFocusPainted(false);
        button.setContentAreaFilled(false);
        button.setPreferredSize(new Dimension(220, 44));

        button.addMouseListener(new MouseAdapter() {
            public void mouseEntered(MouseEvent e) {
                button.setBackground(hoverColor);
                button.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }
            public void mouseExited(MouseEvent e) {
                button.setBackground(bgColor);
            }
        });

        button.addActionListener(action);
        return button;
    }

    private void loadPretrainedModel() {
        logArea.append("Loading pretrained ML model...\n");
        try {
            // Simulate loading a pretrained model with a delay
            Thread.sleep(1000);
            mlModel.loadModel();
            logArea.append("Pretrained model loaded successfully.\n\n");
        } catch (Exception e) {
            logArea.append("Error loading model: " + e.getMessage() + "\n");
        }
    }

    private void selectFolder() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Select Folder to Scan");
        fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File folder = fileChooser.getSelectedFile();
            scanFolder(folder);
        }
    }

    private void scanFolder(File folder) {
        logArea.append("Starting scan of folder: " + folder.getPath() + "\n");

        SwingWorker<List<ScanResult>, String> worker = new SwingWorker<>() {
            @Override
            protected List<ScanResult> doInBackground() throws Exception {
                List<ScanResult> results = new ArrayList<>();

                publish("Scanning folder contents...");

                try {
                    Files.walk(folder.toPath())
                            .filter(Files::isRegularFile)
                            .forEach(path -> {
                                publish("Scanning: " + path.getFileName());
                                results.add(mlModel.analyzeFile(path.toFile()));
                            });
                } catch (IOException e) {
                    publish("Error walking directory: " + e.getMessage());
                }

                return results;
            }

            @Override
            protected void process(List<String> chunks) {
                chunks.forEach(s -> logArea.append(s + "\n"));
            }

            @Override
            protected void done() {
                try {
                    List<ScanResult> results = get();
                    displayFolderResults(results);
                } catch (Exception e) {
                    logArea.append("Error completing scan: " + e.getMessage() + "\n");
                }
            }
        };

        worker.execute();
    }

    private void displayFolderResults(List<ScanResult> results) {
        StringBuilder sb = new StringBuilder();
        sb.append("\n=== Folder Scan Summary ===\n");
        sb.append("Total files scanned: ").append(results.size()).append("\n");

        long suspiciousFiles = results.stream()
                .filter(r -> r.classification.equals("suspicious"))
                .count();

        sb.append("Suspicious files found: ").append(suspiciousFiles).append("\n");
        sb.append("=========================\n\n");

        if (suspiciousFiles > 0) {
            sb.append("Suspicious files:\n");
            results.stream()
                    .filter(r -> r.classification.equals("suspicious"))
                    .forEach(r -> {
                        sb.append("- ").append(r.fileName).append("\n");
                        sb.append("  Risk Score: ").append(String.format("%.2f%%", r.riskScore * 100)).append("\n");
                    });
        }

        logArea.append(sb.toString());
    }

    private String formatFileSize(long size) {
        final String[] units = new String[] { "B", "KB", "MB", "GB", "TB" };
        int digitGroups = (int) (Math.log10(size) / Math.log10(1024));
        return String.format("%.1f %s", size / Math.pow(1024, digitGroups), units[digitGroups]);
    }

    // ML Model classes
    private static class MLModel {
        // Added model path constant
        private static final String MODEL_PATH = "malware_classifier.pth";
        private boolean modelLoaded = false;
        private static final Set<String> SUSPICIOUS_PATTERNS = new HashSet<>(Arrays.asList(
                "CreateRemoteThread",
                "VirtualAlloc",
                "WriteProcessMemory",
                "LoadLibrary",
                "WinExec",
                "CreateProcess",
                "ShellExecute"
        ));

        public void loadModel() {
            // In a real implementation, you would load your pretrained model from MODEL_PATH here.
            // For demonstration purposes, we simulate loading the model.
            System.out.println("Loading model from: " + MODEL_PATH);
            // Simulate a small delay in loading
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                // Handle interruption if needed
            }
            modelLoaded = true;
        }

        public ScanResult analyzeFile(File file) {
            if (!modelLoaded) {
                return new ScanResult(file.getName(), file.length(), 0, false, 0, 0, "error - model not loaded");
            }

            try {
                byte[] content = Files.readAllBytes(file.toPath());

                double entropy = calculateEntropy(content);
                boolean hasExecHeader = checkExecutableHeader(content);
                int suspiciousPatterns = detectSuspiciousPatterns(content);

                double riskScore = calculateRiskScore(entropy, hasExecHeader, suspiciousPatterns, content.length);
                String classification = riskScore > 0.5 ? "suspicious" : "safe";

                return new ScanResult(
                        file.getName(),
                        file.length(),
                        entropy,
                        hasExecHeader,
                        suspiciousPatterns,
                        riskScore,
                        classification
                );
            } catch (IOException e) {
                return new ScanResult(file.getName(), file.length(), 0, false, 0, 0, "error");
            }
        }

        private double calculateEntropy(byte[] data) {
            int[] frequencies = new int[256];
            for (byte b : data) {
                frequencies[b & 0xFF]++;
            }

            double entropy = 0;
            for (int frequency : frequencies) {
                if (frequency > 0) {
                    double probability = (double) frequency / data.length;
                    entropy -= probability * (Math.log(probability) / Math.log(2));
                }
            }
            return entropy;
        }

        private boolean checkExecutableHeader(byte[] data) {
            if (data.length < 2) return false;

            // Check for MZ header (Windows executables)
            if (data[0] == 0x4D && data[1] == 0x5A) return true;

            // Check for ELF header (Linux executables)
            if (data.length >= 4 &&
                    data[0] == 0x7F &&
                    data[1] == 0x45 &&
                    data[2] == 0x4C &&
                    data[3] == 0x46) return true;

            // Check for Mach-O header (macOS executables)
            if (data.length >= 4 &&
                    (data[0] == (byte)0xFE && data[1] == (byte)0xED && data[2] == (byte)0xFA && data[3] == (byte)0xCE ||
                            data[0] == (byte)0xCE && data[1] == (byte)0xFA && data[2] == (byte)0xED && data[3] == (byte)0xFE)) {
                return true;
            }

            return false;
        }

        private int detectSuspiciousPatterns(byte[] data) {
            try {
                String content = new String(data, "UTF-8");
                return (int) SUSPICIOUS_PATTERNS.stream()
                        .filter(pattern -> content.contains(pattern))
                        .count();
            } catch (Exception e) {
                return 0;
            }
        }

        private double calculateRiskScore(double entropy, boolean hasExecHeader, int suspiciousPatterns, long fileSize) {
            double score = 0.0;

            // Entropy analysis (high entropy often indicates encryption/packing)
            if (entropy > 7.0) score += 0.3;
            else if (entropy > 6.0) score += 0.15;

            // Executable header presence
            if (hasExecHeader) score += 0.2;

            // Suspicious API patterns
            score += Math.min(0.3, suspiciousPatterns * 0.1);

            // File size analysis (unusually small or large executables)
            if (hasExecHeader) {
                if (fileSize < 1024) score += 0.1; // Suspiciously small
                if (fileSize > 50 * 1024 * 1024) score += 0.1; // Suspiciously large
            }

            return Math.min(1.0, score);
        }
    }

    private static class ScanResult {
        public final String fileName;
        public final long fileSize;
        public final double entropy;
        public final boolean hasExecutableHeader;
        public final int suspiciousPatterns;
        public final double riskScore;
        public final String classification;

        public ScanResult(String fileName, long fileSize, double entropy,
                          boolean hasExecutableHeader, int suspiciousPatterns,
                          double riskScore, String classification) {
            this.fileName = fileName;
            this.fileSize = fileSize;
            this.entropy = entropy;
            this.hasExecutableHeader = hasExecutableHeader;
            this.suspiciousPatterns = suspiciousPatterns;
            this.riskScore = riskScore;
            this.classification = classification;
        }
    }
}
